/* 
 * Copyright (c) 1995 The University of Utah and
 * the Computer Systems Laboratory at the University of Utah (CSL).
 * All rights reserved.
 *
 * Permission to use, copy, modify and distribute this software is hereby
 * granted provided that (1) source code retains these copyright, permission,
 * and disclaimer notices, and (2) redistributions including binaries
 * reproduce the notices in supporting documentation, and (3) all advertising
 * materials mentioning features or use of this software display the following
 * acknowledgement: ``This product includes software developed by the
 * Computer Systems Laboratory at the University of Utah.''
 *
 * THE UNIVERSITY OF UTAH AND CSL ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS
 * IS" CONDITION.  THE UNIVERSITY OF UTAH AND CSL DISCLAIM ANY LIABILITY OF
 * ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * CSL requests users of this software to return to csl-dist@cs.utah.edu any
 * improvements that they make and grant CSL redistribution rights.
 *
 *      Author: Bryan Ford, University of Utah CSL
 */
/*
 * Glue for the Flick's Mach 3 backend.  (Flick := Flexible IDL Compiler Kit.)
 * This file is included from every stub source code (.c) file generated by that backend.
 * Stubs are built primarily out of invocations of these macros.
 */
/**
 * @file mach/flick_mach3_glue.h
 * @brief Internal glue code for Flick's Mach 3 backend.
 *
 * This file provides internal data structures and macros used by the
 * client and server stubs generated by Flick (Flexible IDL Compiler Kit)
 * for Mach 3 RPCs. It handles message buffer management, and encoding/decoding
 * of primitive types and ports.
 */
#ifndef _MACH_FLICK_MACH3_GLUE_H_
#define _MACH_FLICK_MACH3_GLUE_H_

#include <stdlib.h> /* For malloc, free etc. - though not directly visible, assumed by flick_mach3_rpc_grow_buf */
#include <string.h> /* For memcpy etc. - though not directly visible, assumed by type encoding/decoding */
#include <mach/flick_mach3.h> /* For MOM types like mom_ref_t */


/** @name Internal Flick Data Types */
/**@{*/

/**
 * @struct flick_mach3_rpc_desc
 * @brief RPC descriptor for client-side stubs.
 *
 * Each client stub allocates one of these on its stack to hold
 * important generic state throughout RPC processing, primarily related
 * to message buffer management and marshaling/unmarshaling offsets.
 */
struct flick_mach3_rpc_desc
{
	/**
	 * Pointer to the message buffer.
	 * Initially points to `init_buf`, but is dynamically re-allocated
	 * by `flick_mach3_rpc_grow_buf` if more space is needed.
	 */
	char *msg_buf;
	vm_size_t msg_buf_size;		///< Current size of `msg_buf`.

	/**
	 * Offset of the end of the data marshaled by the client stub
	 * before calling `flick_mach3_rpc()`. Marshaling typically starts
	 * at an offset (e.g., 16 bytes) to leave room for the Mach message header.
	 */
	vm_size_t send_end_ofs;

	/**
	 * Set by `flick_mach3_rpc()` to the offset of the received data to unmarshal.
	 */
	vm_size_t rcv_ofs;
	/**
	 * Set by `flick_mach3_rpc()` to the offset of the end of the received data.
	 */
	vm_size_t rcv_end_ofs;

	/**
	 * Initial inline buffer for the message. The size of this buffer
	 * varies from stub to stub, determined at compile time by Flick.
	 */
	char init_buf[0];
};

/**
 * @struct flick_mach3_rpc_serv_desc
 * @brief RPC descriptor for server-side stubs.
 *
 * Similar to `flick_mach3_rpc_desc`, but used by server stubs.
 * It manages the message buffer for receiving requests and sending replies.
 */
struct flick_mach3_rpc_serv_desc
{
	/**
	 * Pointer to the message buffer.
	 * Initially points to `init_buf`, but can be dynamically re-allocated.
	 */
	char *msg_buf;
	vm_size_t msg_buf_size;		///< Current size of `msg_buf`.

	/**
	 * Offset of the end of the data marshaled by the server stub for the reply.
	 */
	vm_size_t send_end_ofs;

	/**
	 * Offset of the received request data to unmarshal.
	 */
	vm_size_t rcv_ofs;
	/**
	 * Offset of the end of the received request data.
	 */
	vm_size_t rcv_end_ofs;

	/**
	 * Initial inline buffer for the message. The size of this buffer
	 * varies from stub to stub.
	 */
	char init_buf[0];
};
/**@}*/


/** @name Encoding Macros
 * These macros are used by Flick-generated stubs to marshal data into
 * a Mach message buffer. `_desc` is assumed to be a
 * `flick_mach3_rpc_desc` or `flick_mach3_rpc_serv_desc`, and `_e_chunk`
 * is a pointer to the current encoding position within `_desc.d.msg_buf`.
 * @{
 */

/**
 * @def flick_mach3_encode_new_glob(max_size)
 * @brief Ensures space in the message buffer for a new global encoding block.
 * If the current buffer is too small, it calls `flick_mach3_rpc_grow_buf`
 * (not defined here) to reallocate it. Sets `_e_chunk` to the start of the new block.
 * @param max_size The maximum size of the data to be encoded in this block.
 */
#define flick_mach3_encode_new_glob(max_size)						\
{											\
	while (_desc.d.send_end_ofs + (max_size) > _desc.d.msg_buf_size)		\
	{										\
		mach_msg_return_t result = flick_mach3_rpc_grow_buf(&_desc);		\
		/*XXX result: Error handling for grow_buf is not shown here */		\
	}										\
	_e_chunk = _desc.d.msg_buf + _desc.d.send_end_ofs;				\
}

/**
 * @def flick_mach3_encode_end_glob(max_size)
 * @brief Updates the send offset after a global encoding block.
 * @param max_size The actual size of the data encoded in the block.
 */
#define flick_mach3_encode_end_glob(max_size)						\
	_desc.d.send_end_ofs += (max_size);

/**
 * @def flick_mach3_encode_new_chunk(size)
 * @brief Placeholder for starting a new sub-chunk within a global block (currently a no-op).
 * @param size The size of the chunk.
 */
#define flick_mach3_encode_new_chunk(size)	/* do nothing */

/**
 * @def flick_mach3_encode_end_chunk(size)
 * @brief Advances the current encoding pointer `_e_chunk` after encoding a sub-chunk.
 * @param size The size of the encoded sub-chunk.
 */
#define flick_mach3_encode_end_chunk(size)	(_e_chunk += (size))

/**
 * @def flick_mach3_encode_prim(_ofs, _data, _name, _bits, _ctype)
 * @brief Encodes a primitive data type into the message buffer.
 * This involves writing a `mach_msg_type_t` descriptor followed by the data itself.
 * @param _ofs Offset within the current `_e_chunk`.
 * @param _data The data value to encode.
 * @param _name The `msgt_name` for `mach_msg_type_t` (e.g., `MACH_MSG_TYPE_INTEGER_32`).
 * @param _bits The `msgt_size` (in bits) for `mach_msg_type_t`.
 * @param _ctype The C type of the data being encoded.
 */
#define flick_mach3_encode_prim(_ofs, _data, _name, _bits, _ctype)			\
{											\
	struct { mach_msg_type_t _t; _ctype _v; } *_p = (void*)(_e_chunk + _ofs);	\
	mach_msg_type_t _tmpl = { _name, _bits, 1, 1, 0, 0 };				\
	_p->_t = _tmpl; _p->_v = (_data);						\
}

#define flick_mach3_encode_boolean(_ofs, _data)	\
	flick_mach3_encode_prim(_ofs, _data, MACH_MSG_TYPE_BOOLEAN, 32, signed32_t)
#define flick_mach3_encode_char8(_ofs, _data)	\
	flick_mach3_encode_prim(_ofs, _data, MACH_MSG_TYPE_CHAR, 8, signed8_t)
#define flick_mach3_encode_char16(_ofs, _data)	\
	flick_mach3_encode_prim(_ofs, _data, MACH_MSG_TYPE_INTEGER_16, 8, signed16_t) /* Note: bits=8 for char16? Seems like a typo, might mean 16 bits for data, 8 for type name */
#define flick_mach3_encode_signed8(_ofs, _data)	\
	flick_mach3_encode_prim(_ofs, _data, MACH_MSG_TYPE_INTEGER_8, 8, signed8_t)
#define flick_mach3_encode_unsigned8(ofs, data)	\
	flick_mach3_encode_prim(ofs, data, MACH_MSG_TYPE_INTEGER_8, 8, unsigned8_t) /* _ofs, _data were params */
#define flick_mach3_encode_signed16(_ofs, _data)	\
	flick_mach3_encode_prim(_ofs, _data, MACH_MSG_TYPE_INTEGER_16, 16, signed16_t)
#define flick_mach3_encode_unsigned16(ofs, data)	\
	flick_mach3_encode_prim(ofs, data, MACH_MSG_TYPE_INTEGER_16, 16, unsigned16_t) /* _ofs, _data were params */
#define flick_mach3_encode_signed32(_ofs, _data)	\
	flick_mach3_encode_prim(_ofs, _data, MACH_MSG_TYPE_INTEGER_32, 32, signed32_t)
#define flick_mach3_encode_unsigned32(ofs, data)	\
	flick_mach3_encode_prim(ofs, data, MACH_MSG_TYPE_INTEGER_32, 32, unsigned32_t) /* _ofs, _data were params */

/**
 * @def flick_mach3_encode_port(_ofs, _data, _adjust)
 * @brief Encodes a Mach port into the message buffer.
 * Handles reference count adjustments for the port right.
 * @param _ofs Offset within the current `_e_chunk`.
 * @param _data The `mach_port_t` value to encode.
 * @param _adjust Reference count adjustment:
 *                - If > 1, decreases send rights by `_adjust-1`.
 *                - If 0 (or 1), uses `MACH_MSG_TYPE_COPY_SEND` (or `MACH_MSG_TYPE_MOVE_SEND` if _adjust=1 implies move).
 *                  The macro uses `_adjust ? MACH_MSG_TYPE_MOVE_SEND : MACH_MSG_TYPE_COPY_SEND`.
 *                  This suggests _adjust=0 means copy, _adjust=1 (or non-zero) means move.
 *                  However, the `mach_port_mod_refs` call with `-(_adjust-1)` means for _adjust=1, refs are unchanged.
 *                  For _adjust=0, this would be `mach_port_mod_refs(..., +1)`, which is unusual for sending.
 *                  Typical usage: _adjust=0 for copy, _adjust=1 for move (no explicit ref mod), _adjust>1 for move and decrement.
 *                  The `MACH_MSG_TYPE_MOVE_SEND` vs `MACH_MSG_TYPE_COPY_SEND` is based on `_adjust` being non-zero.
 */
#define flick_mach3_encode_port(_ofs, _data, _adjust)					\
{											\
	if (_adjust > 1) { /* Only explicitly mod refs if _adjust indicates more than one ref being consumed by the 'move' */ \
		kern_return_t res = mach_port_mod_refs(mach_task_self(), (_data),	\
			MACH_PORT_RIGHT_SEND, -(_adjust-1));				\
		/* XXX: kern_return_t res should be checked */				\
	}										\
	flick_mach3_encode_prim(_ofs, _data,						\
		_adjust ? MACH_MSG_TYPE_MOVE_SEND : MACH_MSG_TYPE_COPY_SEND, /* If _adjust is non-zero, it's a move */ \
		32, mach_port_t);							\
}
/**@}*/


/** @name Decoding Macros
 * These macros are used by Flick-generated stubs to unmarshal data from
 * a received Mach message buffer. `_desc` is assumed to be a
 * `flick_mach3_rpc_desc` or `flick_mach3_rpc_serv_desc`, `_d_chunk`
 * is a pointer to the current decoding position within `_desc.d.msg_buf`,
 * and `_d_msgsize` is the total size of the received message data.
 * @{
 */

#if TypeCheck
/** @brief Conditional compilation macro for type checking during decoding. */
#define flick_iftypecheck(code) code
#else
#define flick_iftypecheck(code)
#endif

/**
 * @def flick_mach3_decode_new_glob(max_size)
 * @brief Placeholder for starting a new global decoding block (currently a no-op).
 * @param max_size The maximum size of data expected in this block.
 */
#define flick_mach3_decode_new_glob(max_size)

/**
 * @def flick_mach3_decode_end_glob(max_size)
 * @brief Placeholder for ending a global decoding block (currently a no-op).
 * @param max_size The actual size of data decoded.
 */
#define flick_mach3_decode_end_glob(max_size)

/**
 * @def flick_mach3_decode_new_chunk(size)
 * @brief Sets up the `_d_chunk` pointer for decoding a new data chunk.
 * If `TypeCheck` is enabled, it verifies that reading `size` bytes
 * will not go past the end of the received message (`_d_msgsize`).
 * @param size The size of the data chunk to decode.
 * @note `XXX throw MIG_TYPE_ERROR` indicates where an error should be raised.
 */
#define flick_mach3_decode_new_chunk(size)						\
{											\
	flick_iftypecheck(								\
		if (_desc.d.rcv_ofs + (size) > _d_msgsize)				\
			/* XXX throw MIG_TYPE_ERROR; */ ;					\
	);										\
	_d_chunk = _desc.d.msg_buf + _desc.d.rcv_ofs;					\
}

/**
 * @def flick_mach3_decode_end_chunk(size)
 * @brief Advances the receive offset `_desc.d.rcv_ofs` after decoding a chunk.
 * @param size The size of the decoded chunk.
 */
#define flick_mach3_decode_end_chunk(size)						\
	_desc.d.rcv_ofs += (size);

/**
 * @def flick_mach3_decode_prim(_ofs, _data, _name, _bits, _ctype)
 * @brief Decodes a primitive data type from the message buffer.
 * If `TypeCheck` is enabled, it verifies the `mach_msg_type_t` descriptor.
 * @param _ofs Offset within the current `_d_chunk`.
 * @param _data Output parameter where the decoded data will be stored.
 * @param _name Expected `msgt_name` for `mach_msg_type_t`.
 * @param _bits Expected `msgt_size` (in bits) for `mach_msg_type_t`.
 * @param _ctype The C type of the data being decoded.
 * @note `XXX throw MIG_TYPE_ERROR` indicates where an error should be raised.
 */
#define flick_mach3_decode_prim(_ofs, _data, _name, _bits, _ctype)			\
{											\
	struct { mach_msg_type_t _t; _ctype _v; } *_p = (void*)(_d_chunk + _ofs);	\
	flick_iftypecheck( ({								\
		mach_msg_type_t _tmpl = { _name, _bits, 1, 1, 0, 0 };			\
		if (*((signed32_t*)&_tmpl) != *((signed32_t)&_p->_t))			\
			/* XXX throw MIG_TYPE_ERROR; */ ;					\
	}) )										\
	(_data) = _p->_v;								\
}

#define flick_mach3_decode_boolean(_ofs, _data)	\
	flick_mach3_decode_prim(_ofs, _data, MACH_MSG_TYPE_BOOLEAN, 32, signed32_t)
#define flick_mach3_decode_char8(_ofs, _data)	\
	flick_mach3_decode_prim(_ofs, _data, MACH_MSG_TYPE_CHAR, 8, signed8_t)
#define flick_mach3_decode_char16(_ofs, _data)	\
	flick_mach3_decode_prim(_ofs, _data, MACH_MSG_TYPE_INTEGER_16, 8, signed16_t) /* Note: bits=8 for char16? See encode. */
#define flick_mach3_decode_signed8(_ofs, _data)	\
	flick_mach3_decode_prim(_ofs, _data, MACH_MSG_TYPE_INTEGER_8, 8, signed8_t)
#define flick_mach3_decode_unsigned8(_ofs, _data)	\
	flick_mach3_decode_prim(_ofs, _data, MACH_MSG_TYPE_INTEGER_8, 8, unsigned8_t)
#define flick_mach3_decode_signed16(_ofs, _data)	\
	flick_mach3_decode_prim(_ofs, _data, MACH_MSG_TYPE_INTEGER_16, 16, signed16_t)
#define flick_mach3_decode_unsigned16(_ofs, _data)	\
	flick_mach3_decode_prim(_ofs, _data, MACH_MSG_TYPE_INTEGER_16, 16, unsigned16_t)
#define flick_mach3_decode_signed32(_ofs, _data)	\
	flick_mach3_decode_prim(_ofs, _data, MACH_MSG_TYPE_INTEGER_32, 32, signed32_t)
#define flick_mach3_decode_unsigned32(_ofs, _data)	\
	flick_mach3_decode_prim(_ofs, _data, MACH_MSG_TYPE_INTEGER_32, 32, unsigned32_t)

/**
 * @def flick_mach3_decode_port(_ofs, _data, _adjust)
 * @brief Decodes a Mach port from the message buffer.
 * Handles reference count adjustments for the received port right.
 * @param _ofs Offset within the current `_d_chunk`.
 * @param _data Output parameter for the decoded `mach_port_t`.
 * @param _adjust Reference count adjustment:
 *                - If `_adjust != 1`, modifies send rights by `_adjust-1`.
 *                  This is typically used if the sender moved more than one reference
 *                  or if the receiver needs fewer/more references than provided by a simple receive.
 *                  For a standard receive of a send-once right (which becomes a send right),
 *                  _adjust would often be 1 (no change) or 0 (decrement if only a temporary ref is needed).
 */
#define flick_mach3_decode_port(_ofs, _data, _adjust)					\
{											\
	flick_mach3_decode_prim(_ofs, _data, MACH_MSG_TYPE_PORT_SEND, 32, mach_port_t);	\
	if (_adjust != 1) { /* Only explicitly mod refs if _adjust is not 1 */	\
		kern_return_t res = mach_port_mod_refs(mach_task_self(), (_data),	\
			MACH_PORT_RIGHT_SEND, _adjust-1);				\
		/* XXX: kern_return_t res should be checked */				\
	}										\
}
/**@}*/


/** @name Client-side RPC Support */
/**@{*/

/**
 * @brief Performs a Mach RPC.
 * This function is the core of client-side RPCs generated by Flick.
 * It sends the marshaled request message and waits for/receives the reply.
 * @param rpc Pointer to the `flick_mach3_rpc_desc` containing RPC state and buffers.
 * @param send_target The `mach_port_t` of the server to send the RPC to.
 * @param send_msgh_bits The `msgh_bits` field for the Mach message header (e.g., complexity).
 * @return A `mach_msg_return_t` indicating the outcome of the `mach_msg` call.
 *         The received message data will be in `rpc->msg_buf`, with offsets
 *         `rpc->rcv_ofs` and `rpc->rcv_end_ofs` updated.
 * @note The actual `flick_mach3_rpc_grow_buf` function used by encoding macros
 *       is not defined in this header but is assumed to be part of the Flick runtime.
 */
mach_msg_return_t flick_mach3_rpc(struct flick_mach3_rpc_desc *rpc,
				  mach_port_t send_target, mach_msg_bits_t send_msgh_bits);

/**
 * @def flick_mach3_rpc_macro(iscomplex)
 * @brief Macro to simplify calling `flick_mach3_rpc`.
 * Assumes `_desc.d` is the `flick_mach3_rpc_desc` and `_msg_request` (commented XXX)
 * is the target port. Sets standard `msgh_bits` for sending and receiving.
 * @param iscomplex Boolean, true if the message uses complex types (OOL ports/memory).
 */
#define flick_mach3_rpc_macro(iscomplex)						\
{											\
	kern_return_t result = flick_mach3_rpc(&_desc.d, _msg_request/*XXX: _msg_request should be send_target*/, \
		(iscomplex ? MACH_MSGH_BITS_COMPLEX : 0)				\
		| MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE));\
	/* XXX: kern_return_t result should be checked */				\
}
/**@}*/

#endif /* _MACH_FLICK_MACH3_GLUE_H_ */
