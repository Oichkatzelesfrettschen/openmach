#!/bin/bash
set -e
set -x

# --- Helper function to apply sed changes ---
apply_change() {
    local file="$1"
    local sed_expr="$2"
    local grep_check_pattern="$3" # Pattern to check if change is already applied
    local tmp_file=$(mktemp)

    # Check if the change is already applied to prevent duplicate changes
    # Using a more specific grep pattern based on the actual change
    if ! grep -qF -- "$grep_check_pattern" "$file"; then
        sed "$sed_expr" "$file" > "$tmp_file" && mv "$tmp_file" "$file"
        echo "Applied change to $file: $grep_check_pattern"
    else
        echo "Change already applied to $file: $grep_check_pattern"
    fi
    rm -f "$tmp_file"
}

# 1. Modify mig/migcom.c
# Add #include <string.h>
apply_change "mig/migcom.c" "1i\#include <string.h>" "#include <string.h>"
# Change void main to int main
apply_change "mig/migcom.c" "s/void main(int argc, char \*\*argv)/int main(int argc, char **argv)/" "int main(int argc, char **argv)"

# Add return 0; at the end of main if not exiting
# Check if the last few lines of main's body already have return or exit
# This is a simplified check. A more robust check would involve parsing C code.
if ! tail -n 10 "mig/migcom.c" | sed '/^\s*\*\//d; /^\s*\/\//d' | grep -E -q "(\breturn\b|\bexit\b\s*\()"; then
    # Try to insert "return 0;" before the last closing brace of the main function.
    # This sed command looks for the last line that is just '}' and inserts 'return 0;' before it.
    # It's not perfect but should work for typical main() function structures.
    sed -i '$i\return 0;' mig/migcom.c
    echo "Added return 0; to mig/migcom.c"
else
    echo "Skipping adding return 0; to mig/migcom.c as exit() or return likely present."
fi


# 2. Attempt to build mig with debug symbols
echo "Attempting to build mig with debug symbols..."

# Modify i386/mig/Makefile.in to add -g to HOST_CFLAGS
# This will be picked up by Makeconf when configure generates it.
apply_change "i386/Makeconf.in" "/^HOST_CFLAGS[ \t]*=/ s/$/ -g/" "HOST_CFLAGS.*-g"

# The following changes to mig/Makerules are an alternative way to add -g,
# but modifying Makeconf.in is cleaner.
# apply_change "mig/Makerules" "/\$(HOST_CC) \$(HOST_LDFLAGS) -o \$@ \$(MIGCOM_OBJS) \$(LIBS)/i\
# MIGCOM_CFLAGS = -g" "MIGCOM_CFLAGS = -g"
# apply_change "mig/Makerules" "s/\$(HOST_CC) -c \$(HOST_CFLAGS)/\$(HOST_CC) -c \$(HOST_CFLAGS) \$(MIGCOM_CFLAGS)/g" "MIGCOM_CFLAGS)/g"


# Rebuild mig first
echo "Rebuilding mig..."
# Clean previous mig build to ensure new flags are used
if ! make -C i386/mig clean; then
    echo "make clean for mig failed, but continuing."
fi
# Configure i386 first to regenerate Makefiles including i386/mig/Makefile from Makefile.in
# This ensures HOST_CFLAGS with -g from Makeconf.in is propagated.
echo "Running configure in i386 directory..."
if ! (cd i386 && ./configure); then
    echo "Configure script failed in i386. Exiting."
    cat i386/config.log
    exit 1
fi

echo "Building mig in i386/mig directory..."
if ! make -C i386/mig; then
    echo "Failed to rebuild mig with debug symbols."
    exit 1
fi
echo "mig rebuilt successfully with debug symbols."

# 3. Re-attempt the full build
cd i386

# Configure was just run, so Makefiles should be up to date.
# if ./configure; then
#   echo "Configure script completed successfully."
# else
#   echo "Configure script failed. Exiting."
#   cat config.log
#   exit 1
# fi

echo "Attempting full build again..."
# Enable core dumps
ulimit -c unlimited
echo "Core dump enabled. Pattern: $(cat /proc/sys/kernel/core_pattern 2>/dev/null || echo 'permission denied to read core_pattern')"
echo "Working directory: $(pwd)"

if make VERBOSE=1; then
  echo "Build completed successfully."
else
  echo "Build failed. See output for errors."
  echo "Checking for core dumps in the current directory (i386) and subdirectories..."
  find . -name 'core*' -ls

  # --- GDB Analysis ---
  echo "Attempting GDB analysis..."
  if ! command -v gdb &> /dev/null
  then
      echo "gdb not found, installing..."
      sudo apt-get update && sudo apt-get install -y gdb
  fi

  # The mig executable that crashed should be i386/mig/mig
  # The core dump was found in i386/libmach/core
  # GDB needs to be run from the directory where relative paths in the binary make sense,
  # or it might have trouble finding sources. The i386 directory seems appropriate.
  # However, mig is usually invoked from i386/libmach when it crashes.
  # Let's try running gdb from the root /app directory first.
  # The mig executable that is compiled is /app/i386/mig/migcom
  # The /app/i386/mig/mig script is a wrapper that calls migcom.
  # The core dump was generated by migcom.
  # The core file is /app/i386/libmach/core

  MIG_COMPILED_EXEC="/app/i386/mig/migcom"
  CORE_FILE="/app/i386/libmach/core" # Path from find output

  if [ -f "$MIG_COMPILED_EXEC" ] && [ -f "$CORE_FILE" ]; then
    echo "Running GDB on migcom with core dump..."
    # Run GDB in batch mode to get a backtrace
    gdb -q "$MIG_COMPILED_EXEC" "$CORE_FILE" -ex "set pagination off" -ex "bt" -ex "quit"
  else
    echo "GDB analysis skipped: migcom executable or core file not found."
    echo "MIG_COMPILED_EXEC: $MIG_COMPILED_EXEC (exists: $(test -f $MIG_COMPILED_EXEC && echo yes || echo no))"
    echo "CORE_FILE: $CORE_FILE (exists: $(test -f $CORE_FILE && echo yes || echo no))"
  fi

  exit 1
fi
