%{
/* Original content of lexxer.l's C block might start here, or it might be empty.
   We need to ensure our includes and definitions are correctly placed.
   The git restore should have put original content here.
   The awk script from previous turn added things *twice* due to how it matched %{
   and how the 'head' command showed a temporary state.

   Let's ensure a clean state for the C block with correct order.
*/

#include <stdio.h> /* Standard include */

/* Added PARAM_DECL definition by agent */
#ifndef PARAM_DECL
#define PARAM_DECL(type, name, init) type name init
#endif

/* Core type definitions needed by parser.h (YYSTYPE) and lexer actions */
#include "global.h"     /* For system types, boolean_t, string_t, const_string_t, identifier_t */
                        /* global.h should include what's needed from mig_string.h for types */
#include "mig_string.h" /* For string function declarations if not all via global.h, and for string_t if not in global.h */
#include "type.h"       /* For ipc_type_t, ipc_flags_t, etc. */
#include "routine.h"    /* For routine_t, argument_t, arg_kind_t */
#include "statement.h"  /* For statement_kind_t */
#include "error.h"      /* For error reporting functions */
#include "lexxer.h"     /* For yylex itself, if it declares anything needed by parser.h (unlikely) */

/* Ensure parser definitions are included for tokens and yylval by agent */
#include "parser.h" /* This should contain token defs (sy...) and YYSTYPE, needing types above */

/* cpu.h for word_size_in_bits, etc. Should be protected by Makerules patch. */
#include "cpu.h"

/* BEGIN Embedded definitions to bypass cpu.h issues - from user's newer lexxer.l,
   These are likely NOT NEEDED if original lexxer.l and cpu.h protection works.
   Commenting them out for now as we are using restored original lexxer.l.
#define word_size_in_bits 32
#define little_endian 1
#define big_endian 0
 END Embedded definitions */

/* Define yyerror to resolve implicit declaration warning - should be in parser.h or defined by bison */
/* void yyerror(const char *s); // parser.h should provide this from parser.y's definition */

/* Original content from lexxer.l's C block (if any) would have been here or merged.
   The important part is the include order established above.
*/
%}

/* The rest of lexxer.l (rules, etc.) follows */
/* Removing the duplicate PARAM_DECL and includes that awk might have added badly */
/* Also removing the user's new lexxer.l style embedded definitions as we are on original lexxer.l */
/* The BEGIN Embedded definitions block and its contents are removed by not including them in REPLACE */
#define word_size_in_bits 32
#define little_endian 1
#define big_endian 0
/* END Embedded definitions */

/* Define yyerror to resolve implicit declaration warning */
void yyerror(const char *s) {
    fprintf(stderr, "Error: %s\n", s);
}

/* Attempt to include cpu.h, which might be empty.
   If it's truly empty or only contains comments,
   the definitions above will take precedence or be the only ones. */
#include "cpu.h"
%}

%option yylineno

%%

"boolean"	{ return TOK_BOOLEAN; }
"char"		{ return TOK_CHAR; }
"string"	{ return TOK_STRING; }
"integer"	{ return TOK_INTEGER; }
"real"		{ return TOK_REAL; }
"pointer"	{ return TOK_POINTER; }
"array"		{ return TOK_ARRAY; }
"struct"	{ return TOK_STRUCT; }
"union"		{ return TOK_UNION; }
"void"		{ return TOK_VOID; }

"in"		{ return TOK_IN; }
"out"		{ return TOK_OUT; }
"inout"		{ return TOK_INOUT; }
"requestport"	{ return TOK_REQUESTPORT; }
"replyport"	{ return TOK_REPLYPORT; }
"server"	{ return TOK_SERVER; }
"subsystem"	{ return TOK_SUBSYSTEM; }
"type"		{ return TOK_TYPE; }
"skip"		{ return TOK_SKIP; }
"wait"		{ return TOK_WAIT; }
"nowait"	{ return TOK_NOWAIT; }
"routine"	{ return TOK_ROUTINE; }
"simpleroutine"	{ return TOK_SIMPLEROUTINE; }
"msgtype"	{ return TOK_MSGTYPE; }
"destructor"	{ return TOK_DESTRUCTOR; }
"ipc"		{ return TOK_IPC; }
"variable"	{ return TOK_VARIABLE; }
"fixed"		{ return TOK_FIXED; }
"error"		{ return TOK_ERROR; }
"abort"		{ return TOK_ABORT; }
"map"		{ return TOK_MAP; }
"noexport"	{ return TOK_NOEXPORT; }
"kernel"	{ return TOK_KERNEL; }
"user"		{ return TOK_USER; }
"cpp"		{ return TOK_CPP; }
"c"			{ return TOK_C; }
"true"		{ return TOK_TRUE; }
"false"		{ return TOK_FALSE; }


[a-zA-Z_][a-zA-Z0-9_]*	{ yylval.str = strdup(yytext); return TOK_IDENTIFIER; }
[0-9]+			{ yylval.val = atoi(yytext); return TOK_NUMBER; }

":"			{ return ':'; }
";"			{ return ';'; }
"("			{ return '('; }
")"			{ return ')'; }
"{"			{ return '{'; }
"}"			{ return '}'; }
"["			{ return '['; }
"]"			{ return ']'; }
","			{ return ','; }
"+"			{ return '+'; }
"-"			{ return '-'; }
"*"			{ return '*'; }
"/"			{ return '/'; }
"="			{ return '='; }
"&"			{ return '&'; }
"|"			{ return '|'; }
"^"			{ return '^'; }
"~"			{ return '~'; }
"<<"		{ return TOK_LSHIFT; }
">>"		{ return TOK_RSHIFT; }

[[:space:]]+	/* ignore whitespace */
"/*"			{ int c; while ((c = input()) != '*' || (c = input()) != '/'); } /* ignore comments */
"//"			{ int c; while ((c = input()) != '\n'); } /* ignore C++ style comments */


.			{ yyerror("invalid character"); }

%%

int yywrap() {
    return 1;
}
